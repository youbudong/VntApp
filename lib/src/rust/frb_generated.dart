// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/vnt_api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiVntApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.1.0';

  @override
  int get rustContentHash => 1486497214;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_vnt_app',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  VntApiCallback crateApiVntApiVntApiCallbackNew(
      {required FutureOr<void> Function() successFn,
      required FutureOr<void> Function(RustDeviceInfo) createTunFn,
      required FutureOr<void> Function(RustConnectInfo) connectFn,
      required FutureOr<bool> Function(RustHandshakeInfo) handshakeFn,
      required FutureOr<bool> Function(RustRegisterInfo) registerFn,
      required FutureOr<int> Function(RustDeviceConfig) generateTunFn,
      required FutureOr<void> Function(List<RustPeerClientInfo>)
          peerClientListFn,
      required FutureOr<void> Function(RustErrorInfo) errorFn,
      required FutureOr<void> Function() stopFn});

  RustCurrentDeviceInfo crateApiVntApiVntApiCurrentDevice(
      {required VntApi that});

  List<RustPeerClientInfo> crateApiVntApiVntApiDeviceList(
      {required VntApi that});

  String crateApiVntApiVntApiDownStream({required VntApi that});

  Uint64List crateApiVntApiVntApiDownStreamLine(
      {required VntApi that, required String ip});

  String crateApiVntApiVntApiIpDownStreamTotal(
      {required VntApi that, required String ip});

  String crateApiVntApiVntApiIpUpStreamTotal(
      {required VntApi that, required String ip});

  bool crateApiVntApiVntApiIsStopped({required VntApi that});

  RustNatInfo crateApiVntApiVntApiNatInfo({required VntApi that});

  Future<VntApi> crateApiVntApiVntApiNew(
      {required VntConfig vntConfig, required VntApiCallback call});

  RustNatInfo? crateApiVntApiVntApiPeerNatInfo(
      {required VntApi that, required String ip});

  RustRoute? crateApiVntApiVntApiRoute(
      {required VntApi that, required String ip});

  List<(String, List<RustRoute>)> crateApiVntApiVntApiRouteList(
      {required VntApi that});

  void crateApiVntApiVntApiStop({required VntApi that});

  List<(String, BigInt, BigInt)> crateApiVntApiVntApiStreamAll(
      {required VntApi that});

  String crateApiVntApiVntApiUpStream({required VntApi that});

  Uint64List crateApiVntApiVntApiUpStreamLine(
      {required VntApi that, required String ip});

  Future<void> crateApiVntApiInitApp();

  Future<void> crateApiVntApiInitLog();

  Future<VntApi> crateApiVntApiVntInit(
      {required VntConfig vntConfig, required VntApiCallback call});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_VntApi;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_VntApi;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_VntApiPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VntApiCallback;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VntApiCallback;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VntApiCallbackPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  VntApiCallback crateApiVntApiVntApiCallbackNew(
      {required FutureOr<void> Function() successFn,
      required FutureOr<void> Function(RustDeviceInfo) createTunFn,
      required FutureOr<void> Function(RustConnectInfo) connectFn,
      required FutureOr<bool> Function(RustHandshakeInfo) handshakeFn,
      required FutureOr<bool> Function(RustRegisterInfo) registerFn,
      required FutureOr<int> Function(RustDeviceConfig) generateTunFn,
      required FutureOr<void> Function(List<RustPeerClientInfo>)
          peerClientListFn,
      required FutureOr<void> Function(RustErrorInfo) errorFn,
      required FutureOr<void> Function() stopFn}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_DartFn_Inputs__Output_unit_AnyhowException(
            successFn, serializer);
        sse_encode_DartFn_Inputs_rust_device_info_Output_unit_AnyhowException(
            createTunFn, serializer);
        sse_encode_DartFn_Inputs_rust_connect_info_Output_unit_AnyhowException(
            connectFn, serializer);
        sse_encode_DartFn_Inputs_rust_handshake_info_Output_bool_AnyhowException(
            handshakeFn, serializer);
        sse_encode_DartFn_Inputs_rust_register_info_Output_bool_AnyhowException(
            registerFn, serializer);
        sse_encode_DartFn_Inputs_rust_device_config_Output_u_32_AnyhowException(
            generateTunFn, serializer);
        sse_encode_DartFn_Inputs_list_rust_peer_client_info_Output_unit_AnyhowException(
            peerClientListFn, serializer);
        sse_encode_DartFn_Inputs_rust_error_info_Output_unit_AnyhowException(
            errorFn, serializer);
        sse_encode_DartFn_Inputs__Output_unit_AnyhowException(
            stopFn, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiCallbackNewConstMeta,
      argValues: [
        successFn,
        createTunFn,
        connectFn,
        handshakeFn,
        registerFn,
        generateTunFn,
        peerClientListFn,
        errorFn,
        stopFn
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiCallbackNewConstMeta =>
      const TaskConstMeta(
        debugName: "VntApiCallback_new",
        argNames: [
          "successFn",
          "createTunFn",
          "connectFn",
          "handshakeFn",
          "registerFn",
          "generateTunFn",
          "peerClientListFn",
          "errorFn",
          "stopFn"
        ],
      );

  @override
  RustCurrentDeviceInfo crateApiVntApiVntApiCurrentDevice(
      {required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rust_current_device_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiCurrentDeviceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiCurrentDeviceConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_current_device",
        argNames: ["that"],
      );

  @override
  List<RustPeerClientInfo> crateApiVntApiVntApiDeviceList(
      {required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_rust_peer_client_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiDeviceListConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiDeviceListConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_device_list",
        argNames: ["that"],
      );

  @override
  String crateApiVntApiVntApiDownStream({required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiDownStreamConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiDownStreamConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_down_stream",
        argNames: ["that"],
      );

  @override
  Uint64List crateApiVntApiVntApiDownStreamLine(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_64_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiDownStreamLineConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiDownStreamLineConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_down_stream_line",
        argNames: ["that", "ip"],
      );

  @override
  String crateApiVntApiVntApiIpDownStreamTotal(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiIpDownStreamTotalConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiIpDownStreamTotalConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_ip_down_stream_total",
        argNames: ["that", "ip"],
      );

  @override
  String crateApiVntApiVntApiIpUpStreamTotal(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiIpUpStreamTotalConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiIpUpStreamTotalConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_ip_up_stream_total",
        argNames: ["that", "ip"],
      );

  @override
  bool crateApiVntApiVntApiIsStopped({required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiIsStoppedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiIsStoppedConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_is_stopped",
        argNames: ["that"],
      );

  @override
  RustNatInfo crateApiVntApiVntApiNatInfo({required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rust_nat_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiNatInfoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiNatInfoConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_nat_info",
        argNames: ["that"],
      );

  @override
  Future<VntApi> crateApiVntApiVntApiNew(
      {required VntConfig vntConfig, required VntApiCallback call}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vnt_config(vntConfig, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
            call, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVntApiVntApiNewConstMeta,
      argValues: [vntConfig, call],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiNewConstMeta => const TaskConstMeta(
        debugName: "VntApi_new",
        argNames: ["vntConfig", "call"],
      );

  @override
  RustNatInfo? crateApiVntApiVntApiPeerNatInfo(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_rust_nat_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiPeerNatInfoConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiPeerNatInfoConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_peer_nat_info",
        argNames: ["that", "ip"],
      );

  @override
  RustRoute? crateApiVntApiVntApiRoute(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_rust_route,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiRouteConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiRouteConstMeta => const TaskConstMeta(
        debugName: "VntApi_route",
        argNames: ["that", "ip"],
      );

  @override
  List<(String, List<RustRoute>)> crateApiVntApiVntApiRouteList(
      {required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_record_string_list_rust_route,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiRouteListConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiRouteListConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_route_list",
        argNames: ["that"],
      );

  @override
  void crateApiVntApiVntApiStop({required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiStopConstMeta => const TaskConstMeta(
        debugName: "VntApi_stop",
        argNames: ["that"],
      );

  @override
  List<(String, BigInt, BigInt)> crateApiVntApiVntApiStreamAll(
      {required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_record_string_u_64_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiStreamAllConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiStreamAllConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_stream_all",
        argNames: ["that"],
      );

  @override
  String crateApiVntApiVntApiUpStream({required VntApi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiUpStreamConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiUpStreamConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_up_stream",
        argNames: ["that"],
      );

  @override
  Uint64List crateApiVntApiVntApiUpStreamLine(
      {required VntApi that, required String ip}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
            that, serializer);
        sse_encode_String(ip, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_64_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiVntApiUpStreamLineConstMeta,
      argValues: [that, ip],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntApiUpStreamLineConstMeta =>
      const TaskConstMeta(
        debugName: "VntApi_up_stream_line",
        argNames: ["that", "ip"],
      );

  @override
  Future<void> crateApiVntApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<void> crateApiVntApiInitLog() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVntApiInitLogConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiInitLogConstMeta => const TaskConstMeta(
        debugName: "init_log",
        argNames: [],
      );

  @override
  Future<VntApi> crateApiVntApiVntInit(
      {required VntConfig vntConfig, required VntApiCallback call}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vnt_config(vntConfig, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
            call, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiVntApiVntInitConstMeta,
      argValues: [vntConfig, call],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVntApiVntInitConstMeta => const TaskConstMeta(
        debugName: "vnt_init",
        argNames: ["vntConfig", "call"],
      );

  Future<void> Function(
    int,
  ) encode_DartFn_Inputs__Output_unit_AnyhowException(
      FutureOr<void> Function() raw) {
    return (
      callId,
    ) async {
      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw());
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_list_rust_peer_client_info_Output_unit_AnyhowException(
          FutureOr<void> Function(List<RustPeerClientInfo>) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_list_rust_peer_client_info(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_connect_info_Output_unit_AnyhowException(
          FutureOr<void> Function(RustConnectInfo) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_connect_info(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_device_config_Output_u_32_AnyhowException(
          FutureOr<int> Function(RustDeviceConfig) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_device_config(rawArg0);

      Box<int>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_u_32(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_device_info_Output_unit_AnyhowException(
          FutureOr<void> Function(RustDeviceInfo) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_device_info(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_error_info_Output_unit_AnyhowException(
          FutureOr<void> Function(RustErrorInfo) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_error_info(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_handshake_info_Output_bool_AnyhowException(
          FutureOr<bool> Function(RustHandshakeInfo) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_handshake_info(rawArg0);

      Box<bool>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_bool(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_rust_register_info_Output_bool_AnyhowException(
          FutureOr<bool> Function(RustRegisterInfo) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_rust_register_info(rawArg0);

      Box<bool>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_bool(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VntApi => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VntApi => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VntApiCallback => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VntApiCallback => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  VntApi
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VntApiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VntApiCallback
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VntApiCallbackImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VntApi
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VntApiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<void> Function()
      dco_decode_DartFn_Inputs__Output_unit_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(List<RustPeerClientInfo>)
      dco_decode_DartFn_Inputs_list_rust_peer_client_info_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(RustConnectInfo)
      dco_decode_DartFn_Inputs_rust_connect_info_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<int> Function(RustDeviceConfig)
      dco_decode_DartFn_Inputs_rust_device_config_Output_u_32_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(RustDeviceInfo)
      dco_decode_DartFn_Inputs_rust_device_info_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(RustErrorInfo)
      dco_decode_DartFn_Inputs_rust_error_info_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<bool> Function(RustHandshakeInfo)
      dco_decode_DartFn_Inputs_rust_handshake_info_Output_bool_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<bool> Function(RustRegisterInfo)
      dco_decode_DartFn_Inputs_rust_register_info_Output_bool_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  VntApi
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VntApiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VntApiCallback
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VntApiCallbackImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  RustNatInfo dco_decode_box_autoadd_rust_nat_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rust_nat_info(raw);
  }

  @protected
  RustRoute dco_decode_box_autoadd_rust_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rust_route(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  VntConfig dco_decode_box_autoadd_vnt_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_vnt_config(raw);
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint16List;
  }

  @protected
  Uint64List dco_decode_list_prim_u_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeUint64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, List<RustRoute>)> dco_decode_list_record_string_list_rust_route(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_list_rust_route)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, BigInt, BigInt)> dco_decode_list_record_string_u_64_u_64(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_u_64_u_64)
        .toList();
  }

  @protected
  List<(int, int)> dco_decode_list_record_u_32_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_u_32_u_32).toList();
  }

  @protected
  List<(int, int, String)> dco_decode_list_record_u_32_u_32_string(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_u_32_u_32_string)
        .toList();
  }

  @protected
  List<RustPeerClientInfo> dco_decode_list_rust_peer_client_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_rust_peer_client_info)
        .toList();
  }

  @protected
  List<RustRoute> dco_decode_list_rust_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rust_route).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  RustNatInfo? dco_decode_opt_box_autoadd_rust_nat_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rust_nat_info(raw);
  }

  @protected
  RustRoute? dco_decode_opt_box_autoadd_rust_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rust_route(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  Uint16List? dco_decode_opt_list_prim_u_16_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_16_strict(raw);
  }

  @protected
  (String, List<RustRoute>) dco_decode_record_string_list_rust_route(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_list_rust_route(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, BigInt, BigInt) dco_decode_record_string_u_64_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_u_64(arr[1]),
      dco_decode_u_64(arr[2]),
    );
  }

  @protected
  (int, int) dco_decode_record_u_32_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_u_32(arr[1]),
    );
  }

  @protected
  (int, int, String) dco_decode_record_u_32_u_32_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_u_32(arr[1]),
      dco_decode_String(arr[2]),
    );
  }

  @protected
  RustConnectInfo dco_decode_rust_connect_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RustConnectInfo(
      count: dco_decode_usize(arr[0]),
      address: dco_decode_String(arr[1]),
    );
  }

  @protected
  RustCurrentDeviceInfo dco_decode_rust_current_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RustCurrentDeviceInfo(
      virtualIp: dco_decode_String(arr[0]),
      virtualNetmask: dco_decode_String(arr[1]),
      virtualGateway: dco_decode_String(arr[2]),
      virtualNetwork: dco_decode_String(arr[3]),
      broadcastIp: dco_decode_String(arr[4]),
      connectServer: dco_decode_String(arr[5]),
      status: dco_decode_String(arr[6]),
    );
  }

  @protected
  RustDeviceConfig dco_decode_rust_device_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RustDeviceConfig(
      virtualIp: dco_decode_String(arr[0]),
      virtualNetmask: dco_decode_String(arr[1]),
      virtualGateway: dco_decode_String(arr[2]),
      virtualNetwork: dco_decode_String(arr[3]),
      externalRoute: dco_decode_list_record_string_string(arr[4]),
    );
  }

  @protected
  RustDeviceInfo dco_decode_rust_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RustDeviceInfo(
      name: dco_decode_String(arr[0]),
      version: dco_decode_String(arr[1]),
    );
  }

  @protected
  RustErrorInfo dco_decode_rust_error_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RustErrorInfo(
      code: dco_decode_rust_error_type(arr[0]),
      msg: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  RustErrorType dco_decode_rust_error_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RustErrorType.values[raw as int];
  }

  @protected
  RustHandshakeInfo dco_decode_rust_handshake_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RustHandshakeInfo(
      finger: dco_decode_opt_String(arr[0]),
      version: dco_decode_String(arr[1]),
    );
  }

  @protected
  RustNatInfo dco_decode_rust_nat_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RustNatInfo(
      publicIps: dco_decode_list_String(arr[0]),
      natType: dco_decode_String(arr[1]),
      localIpv4: dco_decode_opt_String(arr[2]),
      ipv6: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  RustPeerClientInfo dco_decode_rust_peer_client_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RustPeerClientInfo(
      virtualIp: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      status: dco_decode_String(arr[2]),
      clientSecret: dco_decode_bool(arr[3]),
    );
  }

  @protected
  RustRegisterInfo dco_decode_rust_register_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RustRegisterInfo(
      virtualIp: dco_decode_String(arr[0]),
      virtualNetmask: dco_decode_String(arr[1]),
      virtualGateway: dco_decode_String(arr[2]),
    );
  }

  @protected
  RustRoute dco_decode_rust_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RustRoute(
      protocol: dco_decode_String(arr[0]),
      addr: dco_decode_String(arr[1]),
      metric: dco_decode_u_8(arr[2]),
      rt: dco_decode_i_64(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VntConfig dco_decode_vnt_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 27)
      throw Exception('unexpected arr length: expect 27 but see ${arr.length}');
    return VntConfig(
      tap: dco_decode_bool(arr[0]),
      token: dco_decode_String(arr[1]),
      deviceId: dco_decode_String(arr[2]),
      name: dco_decode_String(arr[3]),
      serverAddressStr: dco_decode_String(arr[4]),
      nameServers: dco_decode_list_String(arr[5]),
      stunServer: dco_decode_list_String(arr[6]),
      inIps: dco_decode_list_record_u_32_u_32_string(arr[7]),
      outIps: dco_decode_list_record_u_32_u_32(arr[8]),
      password: dco_decode_opt_String(arr[9]),
      mtu: dco_decode_opt_box_autoadd_u_32(arr[10]),
      ip: dco_decode_opt_String(arr[11]),
      noProxy: dco_decode_bool(arr[12]),
      serverEncrypt: dco_decode_bool(arr[13]),
      cipherModel: dco_decode_String(arr[14]),
      finger: dco_decode_bool(arr[15]),
      punchModel: dco_decode_String(arr[16]),
      ports: dco_decode_opt_list_prim_u_16_strict(arr[17]),
      firstLatency: dco_decode_bool(arr[18]),
      deviceName: dco_decode_opt_String(arr[19]),
      useChannelType: dco_decode_String(arr[20]),
      packetLossRate: dco_decode_opt_box_autoadd_f_64(arr[21]),
      packetDelay: dco_decode_u_32(arr[22]),
      portMappingList: dco_decode_list_String(arr[23]),
      compressor: dco_decode_String(arr[24]),
      allowWireGuard: dco_decode_bool(arr[25]),
      localIpv4: dco_decode_opt_String(arr[26]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  VntApi
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VntApiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VntApiCallback
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VntApiCallbackImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VntApi
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VntApiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_usize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  VntApi
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VntApiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VntApiCallback
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VntApiCallbackImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  RustNatInfo sse_decode_box_autoadd_rust_nat_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rust_nat_info(deserializer));
  }

  @protected
  RustRoute sse_decode_box_autoadd_rust_route(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rust_route(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  VntConfig sse_decode_box_autoadd_vnt_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_vnt_config(deserializer));
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint16List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, List<RustRoute>)> sse_decode_list_record_string_list_rust_route(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, List<RustRoute>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_list_rust_route(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, BigInt, BigInt)> sse_decode_list_record_string_u_64_u_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, BigInt, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_u_64_u_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<(int, int)> sse_decode_list_record_u_32_u_32(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(int, int)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_u_32_u_32(deserializer));
    }
    return ans_;
  }

  @protected
  List<(int, int, String)> sse_decode_list_record_u_32_u_32_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(int, int, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_u_32_u_32_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RustPeerClientInfo> sse_decode_list_rust_peer_client_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RustPeerClientInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rust_peer_client_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<RustRoute> sse_decode_list_rust_route(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RustRoute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rust_route(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RustNatInfo? sse_decode_opt_box_autoadd_rust_nat_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rust_nat_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RustRoute? sse_decode_opt_box_autoadd_rust_route(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rust_route(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint16List? sse_decode_opt_list_prim_u_16_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_16_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, List<RustRoute>) sse_decode_record_string_list_rust_route(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_list_rust_route(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, BigInt, BigInt) sse_decode_record_string_u_64_u_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    var var_field2 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  (int, int) sse_decode_record_u_32_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (int, int, String) sse_decode_record_u_32_u_32_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    var var_field2 = sse_decode_String(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  RustConnectInfo sse_decode_rust_connect_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_count = sse_decode_usize(deserializer);
    var var_address = sse_decode_String(deserializer);
    return RustConnectInfo(count: var_count, address: var_address);
  }

  @protected
  RustCurrentDeviceInfo sse_decode_rust_current_device_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_virtualIp = sse_decode_String(deserializer);
    var var_virtualNetmask = sse_decode_String(deserializer);
    var var_virtualGateway = sse_decode_String(deserializer);
    var var_virtualNetwork = sse_decode_String(deserializer);
    var var_broadcastIp = sse_decode_String(deserializer);
    var var_connectServer = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    return RustCurrentDeviceInfo(
        virtualIp: var_virtualIp,
        virtualNetmask: var_virtualNetmask,
        virtualGateway: var_virtualGateway,
        virtualNetwork: var_virtualNetwork,
        broadcastIp: var_broadcastIp,
        connectServer: var_connectServer,
        status: var_status);
  }

  @protected
  RustDeviceConfig sse_decode_rust_device_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_virtualIp = sse_decode_String(deserializer);
    var var_virtualNetmask = sse_decode_String(deserializer);
    var var_virtualGateway = sse_decode_String(deserializer);
    var var_virtualNetwork = sse_decode_String(deserializer);
    var var_externalRoute = sse_decode_list_record_string_string(deserializer);
    return RustDeviceConfig(
        virtualIp: var_virtualIp,
        virtualNetmask: var_virtualNetmask,
        virtualGateway: var_virtualGateway,
        virtualNetwork: var_virtualNetwork,
        externalRoute: var_externalRoute);
  }

  @protected
  RustDeviceInfo sse_decode_rust_device_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_version = sse_decode_String(deserializer);
    return RustDeviceInfo(name: var_name, version: var_version);
  }

  @protected
  RustErrorInfo sse_decode_rust_error_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_rust_error_type(deserializer);
    var var_msg = sse_decode_opt_String(deserializer);
    return RustErrorInfo(code: var_code, msg: var_msg);
  }

  @protected
  RustErrorType sse_decode_rust_error_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RustErrorType.values[inner];
  }

  @protected
  RustHandshakeInfo sse_decode_rust_handshake_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_finger = sse_decode_opt_String(deserializer);
    var var_version = sse_decode_String(deserializer);
    return RustHandshakeInfo(finger: var_finger, version: var_version);
  }

  @protected
  RustNatInfo sse_decode_rust_nat_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicIps = sse_decode_list_String(deserializer);
    var var_natType = sse_decode_String(deserializer);
    var var_localIpv4 = sse_decode_opt_String(deserializer);
    var var_ipv6 = sse_decode_opt_String(deserializer);
    return RustNatInfo(
        publicIps: var_publicIps,
        natType: var_natType,
        localIpv4: var_localIpv4,
        ipv6: var_ipv6);
  }

  @protected
  RustPeerClientInfo sse_decode_rust_peer_client_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_virtualIp = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_clientSecret = sse_decode_bool(deserializer);
    return RustPeerClientInfo(
        virtualIp: var_virtualIp,
        name: var_name,
        status: var_status,
        clientSecret: var_clientSecret);
  }

  @protected
  RustRegisterInfo sse_decode_rust_register_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_virtualIp = sse_decode_String(deserializer);
    var var_virtualNetmask = sse_decode_String(deserializer);
    var var_virtualGateway = sse_decode_String(deserializer);
    return RustRegisterInfo(
        virtualIp: var_virtualIp,
        virtualNetmask: var_virtualNetmask,
        virtualGateway: var_virtualGateway);
  }

  @protected
  RustRoute sse_decode_rust_route(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_protocol = sse_decode_String(deserializer);
    var var_addr = sse_decode_String(deserializer);
    var var_metric = sse_decode_u_8(deserializer);
    var var_rt = sse_decode_i_64(deserializer);
    return RustRoute(
        protocol: var_protocol, addr: var_addr, metric: var_metric, rt: var_rt);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VntConfig sse_decode_vnt_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tap = sse_decode_bool(deserializer);
    var var_token = sse_decode_String(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_serverAddressStr = sse_decode_String(deserializer);
    var var_nameServers = sse_decode_list_String(deserializer);
    var var_stunServer = sse_decode_list_String(deserializer);
    var var_inIps = sse_decode_list_record_u_32_u_32_string(deserializer);
    var var_outIps = sse_decode_list_record_u_32_u_32(deserializer);
    var var_password = sse_decode_opt_String(deserializer);
    var var_mtu = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_ip = sse_decode_opt_String(deserializer);
    var var_noProxy = sse_decode_bool(deserializer);
    var var_serverEncrypt = sse_decode_bool(deserializer);
    var var_cipherModel = sse_decode_String(deserializer);
    var var_finger = sse_decode_bool(deserializer);
    var var_punchModel = sse_decode_String(deserializer);
    var var_ports = sse_decode_opt_list_prim_u_16_strict(deserializer);
    var var_firstLatency = sse_decode_bool(deserializer);
    var var_deviceName = sse_decode_opt_String(deserializer);
    var var_useChannelType = sse_decode_String(deserializer);
    var var_packetLossRate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_packetDelay = sse_decode_u_32(deserializer);
    var var_portMappingList = sse_decode_list_String(deserializer);
    var var_compressor = sse_decode_String(deserializer);
    var var_allowWireGuard = sse_decode_bool(deserializer);
    var var_localIpv4 = sse_decode_opt_String(deserializer);
    return VntConfig(
        tap: var_tap,
        token: var_token,
        deviceId: var_deviceId,
        name: var_name,
        serverAddressStr: var_serverAddressStr,
        nameServers: var_nameServers,
        stunServer: var_stunServer,
        inIps: var_inIps,
        outIps: var_outIps,
        password: var_password,
        mtu: var_mtu,
        ip: var_ip,
        noProxy: var_noProxy,
        serverEncrypt: var_serverEncrypt,
        cipherModel: var_cipherModel,
        finger: var_finger,
        punchModel: var_punchModel,
        ports: var_ports,
        firstLatency: var_firstLatency,
        deviceName: var_deviceName,
        useChannelType: var_useChannelType,
        packetLossRate: var_packetLossRate,
        packetDelay: var_packetDelay,
        portMappingList: var_portMappingList,
        compressor: var_compressor,
        allowWireGuard: var_allowWireGuard,
        localIpv4: var_localIpv4);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          VntApi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VntApiImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          VntApiCallback self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VntApiCallbackImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          VntApi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VntApiImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs__Output_unit_AnyhowException(
      FutureOr<void> Function() self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs__Output_unit_AnyhowException(self), serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_list_rust_peer_client_info_Output_unit_AnyhowException(
          FutureOr<void> Function(List<RustPeerClientInfo>) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_list_rust_peer_client_info_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_connect_info_Output_unit_AnyhowException(
      FutureOr<void> Function(RustConnectInfo) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_connect_info_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_device_config_Output_u_32_AnyhowException(
      FutureOr<int> Function(RustDeviceConfig) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_device_config_Output_u_32_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_device_info_Output_unit_AnyhowException(
      FutureOr<void> Function(RustDeviceInfo) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_device_info_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_error_info_Output_unit_AnyhowException(
      FutureOr<void> Function(RustErrorInfo) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_error_info_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_handshake_info_Output_bool_AnyhowException(
      FutureOr<bool> Function(RustHandshakeInfo) self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_handshake_info_Output_bool_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_rust_register_info_Output_bool_AnyhowException(
      FutureOr<bool> Function(RustRegisterInfo) self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_rust_register_info_Output_bool_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        BigInt.from(PlatformPointerUtil.ptrToInt(encodeDartOpaque(
                self, portManager.dartHandlerPort, generalizedFrbRustBinding)))
            .toUnsigned(64),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApi(
          VntApi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VntApiImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVntApiCallback(
          VntApiCallback self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VntApiCallbackImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rust_nat_info(
      RustNatInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rust_nat_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rust_route(
      RustRoute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rust_route(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_vnt_config(
      VntConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_vnt_config(self, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint16List(self);
  }

  @protected
  void sse_encode_list_prim_u_64_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_list_rust_route(
      List<(String, List<RustRoute>)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_list_rust_route(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_u_64_u_64(
      List<(String, BigInt, BigInt)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_u_64_u_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_u_32_u_32(
      List<(int, int)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_u_32_u_32(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_u_32_u_32_string(
      List<(int, int, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_u_32_u_32_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rust_peer_client_info(
      List<RustPeerClientInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rust_peer_client_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rust_route(
      List<RustRoute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rust_route(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rust_nat_info(
      RustNatInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rust_nat_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rust_route(
      RustRoute? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rust_route(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_16_strict(
      Uint16List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_16_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_list_rust_route(
      (String, List<RustRoute>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_list_rust_route(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_u_64_u_64(
      (String, BigInt, BigInt) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
    sse_encode_u_64(self.$3, serializer);
  }

  @protected
  void sse_encode_record_u_32_u_32((int, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
  }

  @protected
  void sse_encode_record_u_32_u_32_string(
      (int, int, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
    sse_encode_String(self.$3, serializer);
  }

  @protected
  void sse_encode_rust_connect_info(
      RustConnectInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.count, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_rust_current_device_info(
      RustCurrentDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.virtualIp, serializer);
    sse_encode_String(self.virtualNetmask, serializer);
    sse_encode_String(self.virtualGateway, serializer);
    sse_encode_String(self.virtualNetwork, serializer);
    sse_encode_String(self.broadcastIp, serializer);
    sse_encode_String(self.connectServer, serializer);
    sse_encode_String(self.status, serializer);
  }

  @protected
  void sse_encode_rust_device_config(
      RustDeviceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.virtualIp, serializer);
    sse_encode_String(self.virtualNetmask, serializer);
    sse_encode_String(self.virtualGateway, serializer);
    sse_encode_String(self.virtualNetwork, serializer);
    sse_encode_list_record_string_string(self.externalRoute, serializer);
  }

  @protected
  void sse_encode_rust_device_info(
      RustDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.version, serializer);
  }

  @protected
  void sse_encode_rust_error_info(
      RustErrorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rust_error_type(self.code, serializer);
    sse_encode_opt_String(self.msg, serializer);
  }

  @protected
  void sse_encode_rust_error_type(
      RustErrorType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rust_handshake_info(
      RustHandshakeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.finger, serializer);
    sse_encode_String(self.version, serializer);
  }

  @protected
  void sse_encode_rust_nat_info(RustNatInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.publicIps, serializer);
    sse_encode_String(self.natType, serializer);
    sse_encode_opt_String(self.localIpv4, serializer);
    sse_encode_opt_String(self.ipv6, serializer);
  }

  @protected
  void sse_encode_rust_peer_client_info(
      RustPeerClientInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.virtualIp, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_bool(self.clientSecret, serializer);
  }

  @protected
  void sse_encode_rust_register_info(
      RustRegisterInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.virtualIp, serializer);
    sse_encode_String(self.virtualNetmask, serializer);
    sse_encode_String(self.virtualGateway, serializer);
  }

  @protected
  void sse_encode_rust_route(RustRoute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.protocol, serializer);
    sse_encode_String(self.addr, serializer);
    sse_encode_u_8(self.metric, serializer);
    sse_encode_i_64(self.rt, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_vnt_config(VntConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.tap, serializer);
    sse_encode_String(self.token, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.serverAddressStr, serializer);
    sse_encode_list_String(self.nameServers, serializer);
    sse_encode_list_String(self.stunServer, serializer);
    sse_encode_list_record_u_32_u_32_string(self.inIps, serializer);
    sse_encode_list_record_u_32_u_32(self.outIps, serializer);
    sse_encode_opt_String(self.password, serializer);
    sse_encode_opt_box_autoadd_u_32(self.mtu, serializer);
    sse_encode_opt_String(self.ip, serializer);
    sse_encode_bool(self.noProxy, serializer);
    sse_encode_bool(self.serverEncrypt, serializer);
    sse_encode_String(self.cipherModel, serializer);
    sse_encode_bool(self.finger, serializer);
    sse_encode_String(self.punchModel, serializer);
    sse_encode_opt_list_prim_u_16_strict(self.ports, serializer);
    sse_encode_bool(self.firstLatency, serializer);
    sse_encode_opt_String(self.deviceName, serializer);
    sse_encode_String(self.useChannelType, serializer);
    sse_encode_opt_box_autoadd_f_64(self.packetLossRate, serializer);
    sse_encode_u_32(self.packetDelay, serializer);
    sse_encode_list_String(self.portMappingList, serializer);
    sse_encode_String(self.compressor, serializer);
    sse_encode_bool(self.allowWireGuard, serializer);
    sse_encode_opt_String(self.localIpv4, serializer);
  }
}

@sealed
class VntApiCallbackImpl extends RustOpaque implements VntApiCallback {
  // Not to be used by end users
  VntApiCallbackImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VntApiCallbackImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VntApiCallback,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiCallback,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiCallbackPtr,
  );
}

@sealed
class VntApiImpl extends RustOpaque implements VntApi {
  // Not to be used by end users
  VntApiImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VntApiImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VntApi,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApi,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VntApiPtr,
  );

  RustCurrentDeviceInfo currentDevice() =>
      RustLib.instance.api.crateApiVntApiVntApiCurrentDevice(
        that: this,
      );

  List<RustPeerClientInfo> deviceList() =>
      RustLib.instance.api.crateApiVntApiVntApiDeviceList(
        that: this,
      );

  String downStream() => RustLib.instance.api.crateApiVntApiVntApiDownStream(
        that: this,
      );

  Uint64List downStreamLine({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiDownStreamLine(that: this, ip: ip);

  String ipDownStreamTotal({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiIpDownStreamTotal(that: this, ip: ip);

  String ipUpStreamTotal({required String ip}) => RustLib.instance.api
      .crateApiVntApiVntApiIpUpStreamTotal(that: this, ip: ip);

  bool isStopped() => RustLib.instance.api.crateApiVntApiVntApiIsStopped(
        that: this,
      );

  RustNatInfo natInfo() => RustLib.instance.api.crateApiVntApiVntApiNatInfo(
        that: this,
      );

  RustNatInfo? peerNatInfo({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiPeerNatInfo(that: this, ip: ip);

  RustRoute? route({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiRoute(that: this, ip: ip);

  List<(String, List<RustRoute>)> routeList() =>
      RustLib.instance.api.crateApiVntApiVntApiRouteList(
        that: this,
      );

  void stop() => RustLib.instance.api.crateApiVntApiVntApiStop(
        that: this,
      );

  List<(String, BigInt, BigInt)> streamAll() =>
      RustLib.instance.api.crateApiVntApiVntApiStreamAll(
        that: this,
      );

  String upStream() => RustLib.instance.api.crateApiVntApiVntApiUpStream(
        that: this,
      );

  Uint64List upStreamLine({required String ip}) =>
      RustLib.instance.api.crateApiVntApiVntApiUpStreamLine(that: this, ip: ip);
}
